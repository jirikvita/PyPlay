#!/usr/bin/python3

# jk 23.2.2020, PRG->FRK->GVA

#from __future__ import print_function

# based on https://realpython.com/python-csv/
# https://matplotlib.org/gallery/lines_bars_and_markers/barh.html#sphx-glr-gallery-lines-bars-and-markers-barh-py
# https://stackoverflow.com/questions/4042192/reduce-left-and-right-margins-in-matplotlib-plot
# https://stackoverflow.com/questions/9764298/is-it-possible-to-sort-two-listswhich-reference-each-other-in-the-exact-same-w
# https://docs.python.org/3/howto/sorting.html
# https://stackoverflow.com/questions/29672375/histogram-in-matplotlib-time-on-x-axis
# https://matplotlib.org/3.1.1/api/dates_api.html

# try also https://docs.python.org/3/library/csv.html ?
# plotting: try
# https://matplotlib.org/3.1.1/gallery/pie_and_polar_charts/pie_and_donut_labels.html#sphx-glr-gallery-pie-and-polar-charts-pie-and-donut-labels-py

#####
# MUST replace in cvs file Děkujeme.... to "Comment"!!!
# Beware! a double key 'Současné etické kauzy na UP' !
#                      'Jsem'
# ...to be always manualy fixed in csv file!;)
# also rektorát => rektorátu :)

# TODO:
# check jsem Muz 1 count difference?
# add option to skip if no comment provided!!!

# Ideas / TODOs:
# check identical answers
#   or answers identical up to 4 responses out of the 31 Q's
# think of correlations! e.g. eticke kauzy vs vstup do ustavu
# make and print a big correlation table?;-)
# animace prubehu v case? ;-)

# fix header of bar plots, fix Informace...

# problem: order in legend depends on how and when met the answer?

import csv, os, sys

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates

from math import log10

from collections import OrderedDict

#########################################
# generate zeros before a string from a short integer like '0012'
def MakeDigitStr(i, digits = 4):
    tag = str(i)
    n = digits
    try: 
        n = int(log10(i))
    except ValueError:
        pass
    if i is 0:
        n = 0
    for i in range(0, digits - n):
        tag = '0' + tag
    return tag

##############################################################
def MakeNtotTitle(i):
   str = MakeDigitStr(i, 2)
   return ' N=' + str

##############################################################

def MakeKeyTag(itag, key):
   keytag = itag + '_' + key
   keytag = keytag.replace(' ','_').replace('/','nebo').replace(',','_').replace('(','_').replace(')','_').replace('?','_')
   return keytag

##############################################################

barCharts = ['Informace získávám', 'Jsem z fakulty / odjinud', 'O anketě jsem se dozvěděl(a) ']

kComment = 'Comment'
kCommentKey = 'Comment'
kEmpty = 'empty'
kNotAnswered = 'Nezodpovězeno'
kTimeStamp = 'Timestamp'
toSkip = [#kComment,
         #kTimeStamp
         ]

def SkipKey(key):
   for toskip in toSkip:
      if toskip in key:
         return True
   return False

def IsCheckListForBarChart(key):
   for bch in barCharts:
      if key == bch:
         return True
   return False



##############################################################

class ccondition:
  # code generated by PrintGettersAndSetters.py
   def __init__(self, reqAnsw, doReq, logic):
      self._reqAnsw = reqAnsw
      self._doReq = doReq
      self._logic = logic

   def GetReqAnsw(self): return self._reqAnsw
   def GetDoReq(self): return self._doReq
   def GetLogic(self): return self._logic

   def SetReqAnsw(self, reqAnsw): self._reqAnsw = reqAnsw
   def SetDoReq(self, doReq): self._doReq = doReq
   def SetLogic(self, logic): self._logic = logic


##############################################################
##############################################################
##############################################################

def makeQuickSummary(filename):

    keys = []
    with open(filename, mode='r') as csv_file:
        csv_reader = csv.DictReader(csv_file)
        line_count = 0
        print('Making keys dict...')
        for row in csv_reader:
           print(row)
           if line_count == 0:
              #print('Column names are')
              #print(row)
              for key in row:
                 keys.append(key)
           else:
              break
           line_count += 1

    results = {} # OrderedDict()
    with open(filename, mode='r') as csv_file:
        csv_reader = csv.DictReader(csv_file)
        line_count = 0
        print('Processing lines...')
        line_count = 0
        for row in csv_reader:
           #print('Processing row')
           #print(row)
           for key in keys:
              if SkipKey(key):
                 continue
              if key == kTimeStamp:
                 answs = row[key].split(';')
                 for answ in answs:
                    #print(answ)
                    try:
                       tmp = results[key]
                    except:
                       results[key] = OrderedDict()
                    results[key][answ] = answ # kinda lame but works with downstream code;)
              else:
                 answs = []
                 if not IsCheckListForBarChart(key):
                    answs.append(row[key])
                 else:
                    answs = row[key].split(';')

                 for answ in answs:
                    #print(answ)
                    try:
                       tmp = results[key]
                    except:
                       results[key] = OrderedDict()
                    try:
                       results[key][answ] = results[key][answ] + 1
                    except:
                       results[key][answ] = 1
                    
           line_count += 1
        print('*** Processed {:} lines.'.format(line_count))
        #print('*** The results and counts are:')
        #print(results)
        return line_count,results
    
##############################################################
def makeResults(filename, filtername, Filter, nReqLines = -1):
    print('*** Processing Filter {}'.format(filtername))

    # Get keys
    keys = []
    with open(filename, mode='r') as csv_file:
        csv_reader = csv.DictReader(csv_file)
        line_count = 0
        print('Making keys dict...')
        for row in csv_reader:
           #print(row)
           if line_count == 0:
              #print('Column names are')
              #print(row)
              for key in row:
                 keys.append(key)
           else:
              break
           line_count += 1

    # Check filter conditions
    results = {} # OrderedDict()
    line_count = 0
    with open(filename, mode='r') as csv_file:
        csv_reader = csv.DictReader(csv_file)
        for row in csv_reader:
           if nReqLines > 0 and line_count >= nReqLines:
              continue
           #print('*** Processing row {}'.format(line_count))
           #print(row)
           # First loop over keys to get the filter condition
           skipBasedOnComments = False
           for fkey in Filter:
              if kComment in fkey:
                 #print('OK, we want to filter on comments field!')
                 Conditions = Filter[fkey]
                 for condition in Conditions:
                    reqAnsw = condition.GetReqAnsw()
                    doReq = condition.GetDoReq()
                    logic = condition.GetLogic()
                    comment = row[kCommentKey]
                    #print(' condition: {} {}'.format(reqAnsw, doReq))
                    #print('  ...the comment is "{}"'.format(comment))
                    # we want non-empty comment:
                    if reqAnsw == kEmpty and doReq == False and comment == '':
                       skipBasedOnComments = True
                       # pop out the first comments condition in next upgrade?
                       #print('    Skip on empty comment request, {}'.format(skipBasedOnComments))
                       break
                    # we want empty comment: 
                    if reqAnsw == kEmpty and doReq == True and comment != '':
                       skipBasedOnComments = True
                       #print('    Skip on non-empty comment request, {}'.format(skipBasedOnComments))
                       break
              if skipBasedOnComments:
                 break

           if skipBasedOnComments:
              #print('         SKIPPING!')
              continue
                       
           #print('         PROCESSING!!')

           toPass = not skipBasedOnComments # True
           for key in keys:
              if SkipKey(key):
                 continue
              answs = []
              if not IsCheckListForBarChart(key):
                 answs.append(row[key])
              else:
                 answs = row[key].split(';')
              for answ in answs:
                 #print('* Processing key "{}"'.format(key))
                 # go through required filter keys
                 for fkey in Filter:
                    if fkey == kCommentKey:
                       continue
                    #print('  processing filter key {}'.format(fkey))
                    if key == fkey:
                         #print('    ok, have matching keys {} and {}'.format(key, fkey))
                         Conditions = Filter[fkey]
                         nCond = len(Conditions)
                         #print('  processing {} conditions'.format(nCond))
                         thisPass = True
                         icond = -1
                         for condition in Conditions:
                             icond = icond + 1
                             #print(condition)
                             reqAnsw = condition.GetReqAnsw()
                             doReq = condition.GetDoReq()
                             logic = condition.GetLogic()
                             #print('      row data are: "{}": "{}"'.format(key, answ))
                             microCondition = False
                             if doReq:
                                 microCondition = reqAnsw in answ
                             else:
                                 microCondition = not ( reqAnsw in answ )
                             if logic == 'OR':
                                #print('        ...ORing with previous condition')
                                thisPass = thisPass or microCondition
                             elif logic == 'AND':
                                #print('        ...ANDing with previous condition')
                                thisPass = thisPass and microCondition
                             elif logic == '' and (nCond == 1 or (nCond > 1 and icond == 0) ):
                                #print('        ...defining as current condition')
                                thisPass = microCondition
                             else:
                                print('        THIS SHOULD NEVER HAPPEN!')
                             #print('       processed key for "{}" condition "{}" "{}" "{}"'.format(fkey, reqAnsw, doReq, logic))
                             #print('       microCondition: {} thisPass: {}'.format(microCondition, thisPass))
                         if thisPass == False:
                            toPass = False
                         #print('  ...done processing conditions!')
                    if not toPass:
                       #print('      leaving filter!')
                       break

                 if not toPass:
                   #print('  FAILED cuts, leaving the key loop!!')
                   continue
           
           # keep filling/counting otherwise:) 
           if toPass:
              #print('  PASSED cuts, filling;-)')
              # Second loop over filter condition to collect the counts
              for key in keys:
                 if SkipKey(key):
                    continue
                 if key == kTimeStamp:
                    answs = row[key].split(';')
                    for answ in answs:
                       #print(answ)
                       try:
                          tmp = results[key]
                       except:
                          results[key] = OrderedDict()
                       results[key][answ] = answ # kinda lame but works with downstream code;)
                 else:
                    answs = []
                    if not IsCheckListForBarChart(key):
                       answs.append(row[key])
                    else:
                       answs = row[key].split(';')

                    #print('   FILLING!')
                    for answ in answs:
                        #print(answ)
                        try:
                           tmp = results[key]
                        except:
                           results[key] = {} # OrderedDict()
                        try:
                           results[key][answ] = results[key][answ] + 1
                        except:
                           results[key][answ] = 1


              line_count += 1



    print('*** Processed {:} lines.'.format(line_count))
    #print('*** The results and counts are:')
    #print(results)
    return line_count,results
    


##############################################################

def func(pct, allvals):
    absolute = int(pct/100.*np.sum(allvals))
    return "{:.1f}%\n({:d})".format(pct, absolute)

##############################################################

def plotresults(dirname, results, nLines, nReqLines = -1, nmaxSegments = 8):

   pies = []
   dirname = 'png_' + dirname 
   if len(dirname) > 0:
      if dirname[-1] != '/':
         dirname = dirname + '/'
   os.system('mkdir -p {}'.format(dirname))
   pdfdirname = dirname
   pdfdirname = pdfdirname.replace('png','pdf')
   if not '00' in dirname:
      os.system('mkdir -p {}'.format(pdfdirname))
   
   ikey = 0
   for key in results:
      #print('In plotresults...')
      data = []
      answers = []
      #print(key, results[key])
      iansw = 0
      for answ in results[key]:
         respondents_count = results[key][answ] 
         if key != kTimeStamp:
            if iansw < nmaxSegments or IsCheckListForBarChart(key):
               data.append(respondents_count)
               leg_answ = answ
               if leg_answ == '':
                  leg_answ = kNotAnswered
               answers.append(leg_answ)
            else:
               data[-1] = data[-1] + respondents_count
               answers[-1] = 'Jinak'
         else:
            data.append(respondents_count)
         iansw = iansw + 1
      #print('plotting {} {}'.format(key, data))
      if not kNotAnswered in answers and key != kTimeStamp:
         data.append(0)
         answers.append(kNotAnswered)
      if key != kTimeStamp:
         data, answers = zip(*sorted(zip(data, answers), reverse=True))
         data, answers = (list(t) for t in zip(*sorted(zip(data, answers), reverse=True)))
      else:
         mdata = mdates.datestr2num(data)
         data = mdata
      if key == kTimeStamp:
         #print('OK, plotting histogram of timestamps!')
         # make a time histogram
         fig, ax = plt.subplots(1,1)
         #print(data)
         ax.hist(data, bins = 100, color = 'blue')
         #ax.xaxis.set_major_locator(mdates.YearLocator())
         ax.xaxis.set_major_locator(mdates.DayLocator())
         ax.xaxis.set_major_formatter(mdates.DateFormatter('%d %h')) # %d.%m.%y'))
         ax.set_title(key + MakeNtotTitle(nLines))
         itag = str(ikey)
         if ikey < 10:
            itag = '0' + itag
         if ikey < 1:
              itag = '00'
         keytag = MakeKeyTag(itag, key)
         plt.savefig('{}{}.png'.format(dirname, keytag))
         if not '00' in dirname:
            plt.savefig('{}{}.pdf'.format(pdfdirname, keytag))
         ikey = ikey + 1
         pies.append(fig)
      elif not IsCheckListForBarChart(key):
         # pie plot
         plt.tight_layout()
         plt.subplots_adjust(left=0.1,wspace = 0.1)
         fig, ax = plt.subplots(figsize=(7, 9), subplot_kw = dict(aspect = "equal"))
         wedges, texts, autotexts = ax.pie(data, autopct = lambda pct: func(pct, data),
                                           textprops = dict(color = "w"))
         ax.legend(wedges, answers,
                   title = key,
                   loc="center left",
                   bbox_to_anchor=(0, 0., 0.5, -0.2)
         )
         plt.setp(autotexts, size=8, weight="bold")
         ax.set_title(key  + MakeNtotTitle(nLines))
         itag = str(ikey)
         if ikey < 10:
            itag = '0' + itag
         keytag = MakeKeyTag(itag, key)
         plt.savefig('{}{}.png'.format(dirname, keytag))
         if not '00' in dirname:
            plt.savefig('{}{}.pdf'.format(pdfdirname, keytag))
         ikey = ikey + 1
         #plt.show()
         pies.append(fig)
      else:
         #print('OK, request for a ybar chart!;-)')
         # ybar chart
         # plt.rcdefaults()
         fig, ax = plt.subplots()
         #fig, ax = plt.subplots(figsize=(10, 3), subplot_kw = dict(aspect = "equal"))
         figsize = [4,4]
         margins = {  #     vvv margin in inches
            "left"   :     2. / figsize[0],
            "bottom" :     0.8 / figsize[1],
            "right"  : 1 - 0.3 / figsize[0],
            "top"    : 1 - 1   / figsize[1]
         }
         fig.subplots_adjust(**margins)
         y_pos = np.arange(len(data))
         #performance = 3 + 10 * np.random.rand(len(data))
         #error = np.random.rand(len(data))
         itag = str(ikey)
         if ikey < 10:
            itag = '0' + itag
         keytag = MakeKeyTag(itag, key)

         #ax.barh(y_pos, data, xerr=error, align='center')
         fdata = []
         #print(data)
         for val in data:
            fdata.append( val / (1.*nLines)*100 )
         #print(fdata)
         ax.barh(y_pos, fdata, align = 'center')
         ax.set_yticks(y_pos)
         ax.set_yticklabels(answers)
         ax.invert_yaxis()  # labels read top-to-bottom
         ax.set_xlabel('Četnost [%]')
         ax.set_title(key + MakeNtotTitle(nLines))
         #plt.show()
         plt.savefig('{}{}.png'.format(dirname, keytag))
         if not '00' in dirname:
            plt.savefig('{}{}.pdf'.format(pdfdirname, keytag))
         pies.append(fig)

   return pies



##############################################################
##############################################################
##############################################################

def main(argv):

    filename = 'Dotaznik.csv'

    Pies = []
    
    allResults = []
    
    #nLines,sumResults = makeQuickSummary(filename)
    #allResults.append(sumResults)
    #pie = plotresults('sumResults', sumResults, nLines)
    #Pies.append(pie)
    
    # and now some Filters;-)
    # structure: key : ['requiredVal', requireNotInvert]
    # if more for one key, then can OR or AND them!
    Filters = { 'All' : {'' : []},
                'Studenti' :    { 'Jsem pracovník' : [ccondition('student', True, '')] },
                'nonStudenti' :    { 'Jsem pracovník' : [ccondition('student', False, '')] },
                'Muzi' :    { 'Jsem' : [ccondition('muž', True, '')] },
                'NonMuzi' :    { 'Jsem' : [ccondition('muž', False, '')] },
                'Zeny' :    { 'Jsem' : [ccondition('žena', True, '')] },
                'PrF' :     { 'Jsem z fakulty / odjinud' : [ ccondition('PřF', True, '') ] },
                'MuziPrF' : { 'Jsem z fakulty / odjinud' : [ ccondition('PřF', True, '') ], 'Jsem' : [ccondition('muž', True, '')] },
                'nonMuziPrF' : { 'Jsem z fakulty / odjinud' : [ ccondition('PřF', True, '') ], 'Jsem' : [ccondition('muž', False, '')] },
                'nonPrF' :  { 'Jsem z fakulty / odjinud' : [ ccondition('PřF', False, '')] },
                'LForFF' :  { 'Jsem z fakulty / odjinud' : [ ccondition('LF', True, ''), ccondition('FF', True, 'OR') ] },
                'MuzLForFF' :  { 'Jsem' : [ccondition('muž', True, '')],
                                 'Jsem z fakulty / odjinud' : [ ccondition('LF', True, ''), ccondition('FF', True, 'OR') ] },
                'Comments' : { kComment : [ccondition(kEmpty, False, '')] },
                'noComments' : { kComment : [ccondition(kEmpty, True, '')] },
    }

    # HACK!!
    # Filters = {}
    
    for filtername in Filters:
        print('### Processing filter {}'.format(filtername))
        nLines,results = makeResults(filename, filtername, Filters[filtername])
        allResults.append(results)
        pie = plotresults(filtername, results, nLines)
        Pies.append(pie)
        if filtername == 'All':
           for nReqLines in range(1, nLines, 5):
              print('### Processing filter {}, iteration {}'.format(filtername, nReqLines))
              nLines2,results2 = makeResults(filename, filtername, Filters[filtername], nReqLines)
              allResults.append(results2)
              pie2 = plotresults(filtername + '_' + MakeDigitStr(nReqLines), results2, nReqLines)
              Pies.append(pie2)
           


###################################
###################################
###################################

if __name__ == "__main__":
    # execute only if run as a script"
    main(sys.argv)
    
###################################
###################################
###################################



